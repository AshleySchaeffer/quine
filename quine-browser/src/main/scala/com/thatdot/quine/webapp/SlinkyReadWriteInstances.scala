package com.thatdot.quine.webapp

import java.time.Instant

import scala.scalajs.js

import io.circe.Json
import io.circe.scalajs.{convertJsToJson, convertJsonToJs}
import slinky.readwrite.{CoreReaders, Reader, Writer}

import com.thatdot.quine.routes.exts.NamespaceParameter
import com.thatdot.quine.routes.{UiEdge, UiNode}

// Slinky Reader / Writer instances. Used by e.g. the code generated by its `@react` macro
// Without these, the @react macro may throw warnings when trying to serialize/deserialize
// certain types, such as `Instant`, `NamespaceParameter`, `UiNode`, and `UiEdge`.
object SlinkyReadWriteInstances extends CoreReaders {
  // These are unused at runtime as far as I can tell, but Slinky requires them at build time.
  // The cast here is because convertJsonToJs returns as `js.Any`, while Slinky's `Writer`
  // requires a `js.Object`. Slinky's own `Writer` instances for strings, ints, bools, etc
  // are implemented as just `.asInstanceOf[js.Object]` anyways, so this seems fine.
  implicit val jsonWriter: Writer[Json] = json => convertJsonToJs(json).asInstanceOf[js.Object]
  implicit val jsonReader: Reader[Json] = js => convertJsToJson(js).fold(throw _, identity)

  implicit val namespaceWriter: Writer[NamespaceParameter] = _.namespaceId.asInstanceOf[js.Object]
  implicit val namespaceReader: Reader[NamespaceParameter] = js =>
    NamespaceParameter(stringReader.read(js)) getOrElse (throw new IllegalArgumentException(
      s"$js is not a valid namespace name"
    ))

  implicit val instantWriter: Writer[Instant] = instant => Json.fromString(instant.toString).asInstanceOf[js.Object]
  implicit val instantReader: Reader[Instant] = js =>
    convertJsToJson(js)
      .flatMap(_.as[String])
      .map(Instant.parse)
      .fold(throw _, identity)

  implicit val uiNodeWriter: Writer[UiNode[String]] = node =>
    Json
      .obj(
        "id" -> Json.fromString(node.id.toString),
        "hostIndex" -> Json.fromInt(node.hostIndex),
        "label" -> Json.fromString(node.label),
        "properties" -> Json.obj(node.properties.toSeq.map { case (k, v) => k -> v }: _*)
      )
      .asInstanceOf[js.Object]

  implicit val uiNodeReader: Reader[UiNode[String]] = js =>
    convertJsToJson(js)
      .flatMap { json =>
        for {
          id <- json.hcursor.get[String]("id")
          hostIndex <- json.hcursor.get[Int]("hostIndex")
          label <- json.hcursor.get[String]("label")
          properties <- json.hcursor.get[Map[String, Json]]("properties")
        } yield UiNode(id, hostIndex, label, properties)
      }
      .fold(throw _, identity)

  implicit val uiEdgeWriter: Writer[UiEdge[String]] = edge =>
    Json
      .obj(
        "from" -> Json.fromString(edge.from.toString),
        "edgeType" -> Json.fromString(edge.edgeType),
        "to" -> Json.fromString(edge.to.toString),
        "isDirected" -> Json.fromBoolean(edge.isDirected)
      )
      .asInstanceOf[js.Object]

  implicit val uiEdgeReader: Reader[UiEdge[String]] = js =>
    convertJsToJson(js)
      .flatMap { json =>
        for {
          from <- json.hcursor.get[String]("from")
          edgeType <- json.hcursor.get[String]("edgeType")
          to <- json.hcursor.get[String]("to")
          isDirected <- json.hcursor.get[Boolean]("isDirected")
        } yield UiEdge(from, edgeType, to, isDirected)
      }
      .fold(throw _, identity)

  // Aliases for QueryUiEvent.Node and QueryUiEvent.Edge
  implicit val nodeWriter: Writer[UiNode[String]] = uiNodeWriter
  implicit val nodeReader: Reader[UiNode[String]] = uiNodeReader
  implicit val edgeWriter: Writer[UiEdge[String]] = uiEdgeWriter
  implicit val edgeReader: Reader[UiEdge[String]] = uiEdgeReader

  implicit val uiEdgeJsonWriter: io.circe.Encoder[UiEdge[String]] = edge =>
    Json.obj(
      "from" -> Json.fromString(edge.from.toString),
      "edgeType" -> Json.fromString(edge.edgeType),
      "to" -> Json.fromString(edge.to.toString),
      "isDirected" -> Json.fromBoolean(edge.isDirected)
    )

  implicit val uiNodeJsonWriter: io.circe.Encoder[UiNode[String]] = node =>
    Json.obj(
      "id" -> Json.fromString(node.id.toString),
      "hostIndex" -> Json.fromInt(node.hostIndex),
      "label" -> Json.fromString(node.label),
      "properties" -> Json.obj(node.properties.toSeq.map { case (k, v) => k -> v }: _*)
    )

  // Explicit Writers and Readers for Seq[UiNode[String]] and Seq[UiEdge[String]]
  implicit val seqUiNodeWriter: Writer[Seq[UiNode[String]]] = seq => {
    val jsonArray = seq.map(node => convertJsonToJs(uiNodeJsonWriter(node)).asInstanceOf[js.Any])
    js.Array(jsonArray: _*).asInstanceOf[js.Object]
  }

  implicit val seqUiNodeReader: Reader[Seq[UiNode[String]]] = js => {
    convertJsToJson(js)
      .flatMap { json =>
        json.asArray match {
          case Some(jsonArray) =>
            val elements =
              jsonArray.map(jsElem => uiNodeReader.read(convertJsonToJs(jsElem).asInstanceOf[scala.scalajs.js.Object]))
            Right(elements.toSeq)
          case None => Left(new IllegalArgumentException("Expected JSON array"))
        }
      }
      .fold(throw _, identity)
  }

  implicit val seqUiEdgeWriter: Writer[Seq[UiEdge[String]]] = seq => {
    val jsonArray = seq.map(edge => convertJsonToJs(uiEdgeJsonWriter(edge)).asInstanceOf[js.Any])
    js.Array(jsonArray: _*).asInstanceOf[js.Object]
  }

  implicit val seqUiEdgeReader: Reader[Seq[UiEdge[String]]] = js => {
    convertJsToJson(js)
      .flatMap { json =>
        json.asArray match {
          case Some(jsonArray) =>
            val elements =
              jsonArray.map(jsElem => uiEdgeReader.read(convertJsonToJs(jsElem).asInstanceOf[scala.scalajs.js.Object]))
            Right(elements.toSeq)
          case None => Left(new IllegalArgumentException("Expected JSON array"))
        }
      }
      .fold(throw _, identity)
  }
}
